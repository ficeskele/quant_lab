<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ‰‹å‹¢åµæ¸¬æ¸¬è©¦é é¢</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: Arial, sans-serif;
      background: #000;
      color: #fff;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    h1 {
      text-align: center;
      color: #00ffff;
    }

    .video-container {
      position: relative;
      display: inline-block;
      margin: 20px;
    }

    #video {
      width: 640px;
      height: 480px;
      border: 2px solid #00ffff;
      transform: scaleX(-1);
    }

    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 640px;
      height: 480px;
      pointer-events: none;
    }

    .info {
      margin: 20px;
      padding: 20px;
      background: rgba(0, 255, 255, 0.1);
      border: 1px solid #00ffff;
      border-radius: 8px;
    }

    .gesture-display {
      font-size: 48px;
      text-align: center;
      margin: 20px 0;
      color: #ffff00;
    }

    .debug-info {
      font-family: monospace;
      font-size: 14px;
      line-height: 1.6;
    }

    .status {
      display: inline-block;
      padding: 5px 10px;
      border-radius: 4px;
      margin: 5px 0;
    }

    .status.ok {
      background: #00ff00;
      color: #000;
    }

    .status.error {
      background: #ff0000;
      color: #fff;
    }

    .status.waiting {
      background: #ffaa00;
      color: #000;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ–ï¸ æ‰‹å‹¢åµæ¸¬æ¸¬è©¦é é¢</h1>

    <div class="info">
      <h2>ç³»çµ±ç‹€æ…‹</h2>
      <div class="debug-info">
        <div>MediaPipe ç‹€æ…‹: <span id="mediapipe-status" class="status waiting">åˆå§‹åŒ–ä¸­...</span></div>
        <div>æ”åƒé ­ç‹€æ…‹: <span id="camera-status" class="status waiting">ç­‰å¾…ä¸­...</span></div>
        <div>æ‰‹éƒ¨åµæ¸¬: <span id="hand-status" class="status waiting">æœªåµæ¸¬åˆ°</span></div>
      </div>
    </div>

    <div class="gesture-display">
      ç•¶å‰æ‰‹å‹¢: <span id="gesture-name">ç„¡</span>
    </div>

    <div class="video-container">
      <video id="video" autoplay playsinline></video>
      <canvas id="canvas" width="640" height="480"></canvas>
    </div>

    <div class="info">
      <h2>æ”¯æ´çš„æ‰‹å‹¢</h2>
      <div class="debug-info">
        <div>ğŸ–ï¸ FULL_OPEN - äº”æŒ‡ä¼¸ç›´ï¼ˆæ’æ–¥ï¼‰</div>
        <div>ğŸ¤ PINCH - æ‹‡æŒ‡å’Œé£ŸæŒ‡æ¥è§¸ï¼ˆæåˆæŠ“å–ï¼‰</div>
        <div>âœŒï¸ PEACE - é£ŸæŒ‡å’Œä¸­æŒ‡ä¼¸ç›´ï¼ˆåˆ‡æ›æ¨¡å¼ï¼‰</div>
        <div>ğŸ–ï¸ FULL_OPEN - äº”æŒ‡å®Œå…¨å¼µé–‹ï¼ˆé‡ç½®å ´æ™¯ï¼‰</div>
      </div>
    </div>

    <div class="info">
      <h2>èª¿è©¦ä¿¡æ¯</h2>
      <div id="debug-log" class="debug-info" style="max-height: 300px; overflow-y: auto;"></div>
    </div>
  </div>

  <script type="module">
    import { Hands } from 'https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js';
    import { Camera } from 'https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1632432234/camera_utils.js';

    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    const mediapipeStatus = document.getElementById('mediapipe-status');
    const cameraStatus = document.getElementById('camera-status');
    const handStatus = document.getElementById('hand-status');
    const gestureName = document.getElementById('gesture-name');
    const debugLog = document.getElementById('debug-log');

    let logLines = [];

    const PINCH_THRESHOLD = 0.08;
    const EXTENDED_ANGLE_THRESHOLD = 165;
    const CURL_ANGLE_THRESHOLD = 150;
    const PEACE_V_SPREAD_RATIO = 0.35;
    const PEACE_V_MIN_SPREAD = 0.025;
    const FULL_OPEN_SPREAD_THRESHOLD = 0.15;

    function log(message, type = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      const line = `[${timestamp}] ${message}`;
      console.log(line);

      logLines.unshift(line);
      if (logLines.length > 50) logLines.pop();

      debugLog.innerHTML = logLines.join('<br>');
    }

    function updateStatus(element, text, status) {
      element.textContent = text;
      element.className = `status ${status}`;
    }

    const calculateDistance = (p1, p2) => {
      const dx = p1.x - p2.x;
      const dy = p1.y - p2.y;
      const dz = (p1.z || 0) - (p2.z || 0);
      return Math.sqrt(dx * dx + dy * dy + dz * dz);
    };

    const getFingerCurlAngle = (landmarks, tipIndex) => {
      const mcp = landmarks[tipIndex - 3];
      const pip = landmarks[tipIndex - 2];
      const dip = landmarks[tipIndex - 1];

      const v1 = {
        x: mcp.x - pip.x,
        y: mcp.y - pip.y,
        z: (mcp.z || 0) - (pip.z || 0)
      };
      const v2 = {
        x: dip.x - pip.x,
        y: dip.y - pip.y,
        z: (dip.z || 0) - (pip.z || 0)
      };

      const dot = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
      const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z);
      const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y + v2.z * v2.z);

      if (mag1 === 0 || mag2 === 0) return 180;

      const cosAngle = Math.max(-1, Math.min(1, dot / (mag1 * mag2)));
      return Math.acos(cosAngle) * (180 / Math.PI);
    };

    const isFingerExtended = (landmarks, tipIndex) => {
      const tip = landmarks[tipIndex];
      const dip = landmarks[tipIndex - 1];
      const mcp = landmarks[tipIndex - 3];

      const tipToMcp = calculateDistance(tip, mcp);
      const dipToMcp = calculateDistance(dip, mcp);
      const curlAngle = getFingerCurlAngle(landmarks, tipIndex);

      return (tipToMcp > dipToMcp * 1.1) || (curlAngle > EXTENDED_ANGLE_THRESHOLD);
    };

    const isFingerCurled = (landmarks, tipIndex) => {
      const tip = landmarks[tipIndex];
      const dip = landmarks[tipIndex - 1];
      const mcp = landmarks[tipIndex - 3];

      const tipToMcp = calculateDistance(tip, mcp);
      const dipToMcp = calculateDistance(dip, mcp);
      const curlAngle = getFingerCurlAngle(landmarks, tipIndex);

      return (tipToMcp < dipToMcp * 1.05) || (curlAngle < CURL_ANGLE_THRESHOLD);
    };

    const isThumbExtended = (landmarks) => {
      const thumbTip = landmarks[4];
      const thumbMcp = landmarks[2];
      const wrist = landmarks[0];

      const tipToWrist = calculateDistance(thumbTip, wrist);
      const mcpToWrist = calculateDistance(thumbMcp, wrist);

      return tipToWrist > mcpToWrist * 1.3;
    };

    const getPalmWidth = (landmarks) => calculateDistance(landmarks[5], landmarks[17]);

    // ç°¡å–®çš„æ‰‹å‹¢åµæ¸¬
    function detectGesture(landmarks) {
      if (!landmarks || landmarks.length !== 21) return 'NONE';

      // æª¢æ¸¬æåˆ
      const thumbTip = landmarks[4];
      const indexTip = landmarks[8];
      if (calculateDistance(thumbTip, indexTip) < PINCH_THRESHOLD && isThumbExtended(landmarks) && isFingerExtended(landmarks, 8)) {
        return 'PINCH';
      }

      // æª¢æŸ¥æ‰‹æŒ‡ç‹€æ…‹
      const fingers = [
        isFingerExtended(landmarks, 8),  // é£ŸæŒ‡
        isFingerExtended(landmarks, 12), // ä¸­æŒ‡
        isFingerExtended(landmarks, 16), // ç„¡åæŒ‡
        isFingerExtended(landmarks, 20)  // å°æŒ‡
      ];

      const thumbExt = isThumbExtended(landmarks);
      const wrist = landmarks[0];
      const palmWidth = getPalmWidth(landmarks);
      const fingerGap = calculateDistance(landmarks[8], landmarks[12]);
      const requiredGap = Math.max(PEACE_V_MIN_SPREAD, palmWidth * PEACE_V_SPREAD_RATIO);
      const fingerCurls = [
        isFingerCurled(landmarks, 8),
        isFingerCurled(landmarks, 12),
        isFingerCurled(landmarks, 16),
        isFingerCurled(landmarks, 20)
      ];
      const curledCount = fingerCurls.filter(Boolean).length;
      const thumbAboveWrist = (wrist.y - landmarks[4].y) > 0.05;

      // V å­—æ‰‹å‹¢
      if (fingers[0] && fingers[1] && isFingerCurled(landmarks, 16) && isFingerCurled(landmarks, 20) && fingerGap > requiredGap) {
        return 'PEACE';
      }

      // å®Œå…¨å¼µé–‹ï¼ˆæ’æ–¥ï¼‰
      if (fingers.every(f => f) && thumbExt && palmWidth > FULL_OPEN_SPREAD_THRESHOLD) {
        return 'FULL_OPEN';
      }

      return 'NONE';
    }

    // ç¹ªè£½æ‰‹éƒ¨é—œéµé»
    function drawLandmarks(landmarks) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (!landmarks) return;

      // ç¹ªè£½é€£ç·š
      ctx.strokeStyle = '#00ffff';
      ctx.lineWidth = 2;

      const connections = [
        [0, 1], [1, 2], [2, 3], [3, 4],
        [0, 5], [5, 6], [6, 7], [7, 8],
        [0, 9], [9, 10], [10, 11], [11, 12],
        [0, 13], [13, 14], [14, 15], [15, 16],
        [0, 17], [17, 18], [18, 19], [19, 20],
        [5, 9], [9, 13], [13, 17]
      ];

      connections.forEach(([start, end]) => {
        const p1 = landmarks[start];
        const p2 = landmarks[end];

        ctx.beginPath();
        ctx.moveTo(p1.x * canvas.width, p1.y * canvas.height);
        ctx.lineTo(p2.x * canvas.width, p2.y * canvas.height);
        ctx.stroke();
      });

      // ç¹ªè£½é—œéµé»
      landmarks.forEach((point, index) => {
        const x = point.x * canvas.width;
        const y = point.y * canvas.height;

        ctx.fillStyle = [0, 4, 8, 12, 16, 20].includes(index) ? '#ff0000' : '#00ff00';
        ctx.beginPath();
        ctx.arc(x, y, [0, 4, 8, 12, 16, 20].includes(index) ? 5 : 3, 0, 2 * Math.PI);
        ctx.fill();
      });
    }

    async function init() {
      try {
        log('åˆå§‹åŒ– MediaPipe Hands...');

        const hands = new Hands({
          locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`;
          }
        });

        hands.setOptions({
          maxNumHands: 1,
          modelComplexity: 1,
          minDetectionConfidence: 0.7,
          minTrackingConfidence: 0.7,
          selfieMode: true
        });

        hands.onResults((results) => {
          if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            const gesture = detectGesture(landmarks);

            updateStatus(handStatus, 'å·²åµæ¸¬åˆ°æ‰‹éƒ¨', 'ok');
            gestureName.textContent = gesture;

            if (gesture !== 'NONE') {
              log(`åµæ¸¬åˆ°æ‰‹å‹¢: ${gesture}`);
            }

            drawLandmarks(landmarks);
          } else {
            updateStatus(handStatus, 'æœªåµæ¸¬åˆ°æ‰‹éƒ¨', 'waiting');
            gestureName.textContent = 'ç„¡';
            ctx.clearRect(0, 0, canvas.width, canvas.height);
          }
        });

        updateStatus(mediapipeStatus, 'MediaPipe å·²å°±ç·’', 'ok');
        log('MediaPipe åˆå§‹åŒ–æˆåŠŸ');

        // å•Ÿå‹•æ”åƒé ­
        log('è«‹æ±‚æ”åƒé ­æ¬Šé™...');
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: { ideal: 640 },
            height: { ideal: 480 },
            facingMode: 'user'
          }
        });

        video.srcObject = stream;
        await new Promise(resolve => video.onloadedmetadata = resolve);

        updateStatus(cameraStatus, 'æ”åƒé ­å·²å•Ÿå‹•', 'ok');
        log('æ”åƒé ­å•Ÿå‹•æˆåŠŸ');

        const camera = new Camera(video, {
          onFrame: async () => {
            await hands.send({ image: video });
          },
          width: 640,
          height: 480
        });

        await camera.start();
        log('âœ… ç³»çµ±å·²å°±ç·’ï¼Œè«‹å°‡æ‰‹æ”¾å…¥ç•«é¢');

      } catch (error) {
        log(`âŒ éŒ¯èª¤: ${error.message}`, 'error');
        updateStatus(mediapipeStatus, 'åˆå§‹åŒ–å¤±æ•—', 'error');
        updateStatus(cameraStatus, 'ç„¡æ³•å•Ÿå‹•', 'error');
        console.error(error);
      }
    }

    init();
  </script>
</body>
</html>
